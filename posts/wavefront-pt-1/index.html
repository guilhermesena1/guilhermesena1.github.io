<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Wavefront alignments pt 1 : The Myers edit distance algorithm" /><meta property="og:locale" content="en" /><meta name="description" content="This is the first part of a two-part post that explains the wavefront alignment algorithm, a 2020 paper that finds the alignment between two sequences $A$ and $B$ in $O((|A| + |B|)s)$, where $s$ is the alignment “distance”. We are using “distance” instead of “score” because these algorithms only make sense when the match score is 0 and the mismatch, indel and possibly gap-open scores are non-negative." /><meta property="og:description" content="This is the first part of a two-part post that explains the wavefront alignment algorithm, a 2020 paper that finds the alignment between two sequences $A$ and $B$ in $O((|A| + |B|)s)$, where $s$ is the alignment “distance”. We are using “distance” instead of “score” because these algorithms only make sense when the match score is 0 and the mismatch, indel and possibly gap-open scores are non-negative." /><link rel="canonical" href="/posts/wavefront-pt-1/" /><meta property="og:url" content="/posts/wavefront-pt-1/" /><meta property="og:site_name" content="Guilherme Sena" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-22T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Wavefront alignments pt 1 : The Myers edit distance algorithm" /><meta name="twitter:site" content="@senacompbio" /><meta name="google-site-verification" content="google23fa0f88983501d9.html" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-22T00:00:00+00:00","datePublished":"2022-07-22T00:00:00+00:00","description":"This is the first part of a two-part post that explains the wavefront alignment algorithm, a 2020 paper that finds the alignment between two sequences $A$ and $B$ in $O((|A| + |B|)s)$, where $s$ is the alignment “distance”. We are using “distance” instead of “score” because these algorithms only make sense when the match score is 0 and the mismatch, indel and possibly gap-open scores are non-negative.","headline":"Wavefront alignments pt 1 : The Myers edit distance algorithm","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/wavefront-pt-1/"},"url":"/posts/wavefront-pt-1/"}</script><title>Wavefront alignments pt 1 : The Myers edit distance algorithm | Guilherme Sena</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Guilherme Sena"><meta name="application-name" content="Guilherme Sena"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/favicons/android-chrome-512x512.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Guilherme Sena</a></div><div class="site-subtitle font-italic">Create. Not for money, fame or recognition, but for the pure joy of creating something and sharing it.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/guilhermesena1" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/senacompbio" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['desenabr','usc.edu'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Wavefront alignments pt 1 : The Myers edit distance algorithm</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Wavefront alignments pt 1 : The Myers edit distance algorithm</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1658448000" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 22, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/senacompbio">Guilherme Sena</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2936 words"> <em>16 min</em> read</span></div></div></div><div class="post-content"><p>This is the first part of a two-part post that explains the <a href="https://academic.oup.com/bioinformatics/article/37/4/456/5904262">wavefront alignment algorithm</a>, a 2020 paper that finds the alignment between two sequences $A$ and $B$ in $O((|A| + |B|)s)$, where $s$ is the alignment “distance”. We are using “distance” instead of “score” because these algorithms only make sense when the match score is 0 and the mismatch, indel and possibly gap-open scores are non-negative.</p><p>In this first post, we will discuss the <a href="https://link.springer.com/article/10.1007/BF01840446">algorithm</a> introduced by Prof. Gene Myers in 1986. This algorithm is also the basis of the <code class="language-plaintext highlighter-rouge">diff</code> tool in Linux, used to find the differences between two files. I think this says volumes about the algorithm’s relevance. Personally I can only dream of writing an algorithm that will be adopted by a GNU tool.</p><h1 id="motivation">Motivation</h1><p>Many fields in computational biology revolve around finding similarities and differences between extremely large sequences. In most cases, these differences are formalized through approximate string matching problem formulations. <a href="https://www.sciencedirect.com/science/article/abs/pii/0022283681900875">Local</a> and <a href="https://www.sciencedirect.com/science/article/abs/pii/0022283670900574">global</a> alignments are ubiquitous, so a lot of interest exists in creating efficient implementations of alignment algorithms.</p><p>The Needleman-Wunsch and Smith-Waterman alignment algorithms are the only ones guaranteed to find optimal global and local alignment, respectively, of sequences $A$ and $B$ for arbitrary scoring schemes. They are also $\Theta(|A| |B|)$, meaning that, whether $A$ and $B$ are very similar or very different, the number of operations is the same: We have to fill out the entire traceback matrix to find our answer, either as the score at the bottom-right element in the matrix (global alignment) or the maximum element in the matrix (local alignment).</p><p>In most applications in molecular biology, however, we only reach the point of aligning two sequences when there is already some evidence that the two sequences are likely to be similar. This is either because we have prior knowledge of their similarity or because, prior to comparison, we “filtered” a set of candidate sequences for which there is some evidence of similarity. For example, in sequence database search algorithms such as <a href="https://www.sciencedirect.com/science/article/abs/pii/S0022283605803602">BLAST</a> or <a href="https://genomebiology.biomedcentral.com/articles/10.1186">Kraken</a>, we use smaller subsequence in our query (called “seeds”) and only fully compare our sequence to “hits” in the database that match the selected subsequence exactly. This means that the hits already have, by definition, a significant similarity to the sequence. The same procedure of “seeding” is done to map short sequences to a reference genome in mapping algorithms like <a href="https://github.com/lh3/minimap2">minimap2</a>, <a href="https://github.com/smithlabcode/abismal">abismal</a> and literally every other mapping tool ever written in the last 5 years or so.</p><p>For both the purposes of database search and read mapping (which in some sense is also a database search), we want two types of alignment functions. The first type is a “fast” function that only computes the alignment score and nothing else. We want these to perform as fast as possible, and it is in our interest to minimize the number of operations to obtain the score, after all we are only interested in whichever sequence attains the highest score until we actually have to report how the query and the best matching sequence differ. The second “slow” function computes both the score and the exact operations (substitutions, insertions and deletions) that are necessary to transform our query to our best match. This information is used downstream to study <em>how</em> they differ, but we only call this function to the highest scoring candidate among all our hits.</p><p>It is very easy to verify (see <a href="#appendix-the-time-mappers-spend-aligning-reads">appendix</a>) that most of the run time for read mapping algorithms is spent on alignment algorithms to fully compare reads to hits (about 60-65% of the time from the mappers we tested). In fact, we can even see that the most time-consuming step are alignments that <em>do not</em> compute the traceback, in other words, the false-positive alignments. We will therefore focus on alignment algorithms that perform well for highly similar sequences. We will begin with what is possibly the simplest form of alignment of all: the <em>edit distance</em>.</p><h1 id="edit-distance-problem-formulation">Edit distance problem formulation</h1><p>The <em>edit distance</em> $D(A, B)$ between strings $A$ and $B$ is the number of substitutions, deletions and insertions of characters in $A$ to make it identical to $B$. Obviously edit distance is a symmetric, that is, $D(A,B) = D(B,A)$. In fact, edit distance is a metric (can you think of a proof for the triangle inequality?). Similar to alignments, edit distances can be computed in $O(|A| |B|)$ time. Let $A = a_1, \dots a_m$ and $B = b_1, \dots, b_n$ be two strings and for string $S$, $S[i]$ denote the prefix of $S$ with the first $i$ characters, with $S[0]$ being the empty string, then the edit distance $D[i, j]$ of prefix $A[i]$ with prefix $B[j]$ is given by $D[i, 0] = i$, $D[0, j] = j$ and $D[i, j] = D[i - 1, j - 1]$ if $A[i] = B[j]$, or $D[i, j] = 1 + \mathrm{min}(D[i - 1, j - 1], D[i - 1, j], D[i, j-1])$ otherwise. Those who have seen the <a href="https://guilhermesena1.github.io/posts/possibly-the-most-naive-phylogenetic-reconstruction-algorithm">Smith-Waterman recursion</a> should find this recursion familiar, with the exception that we always use $D[i-1, j-1]$ if there is a match, but sometimes we also take diagonals for substitutions of characters.</p><p><strong>A quick note on our definition of edit distance:</strong> In the next section we will describe an algorithm to compute edit distance based on the paper by Prof. Gene Myers. In the original 1986 formulation, he described that the longest common subsequence and the shortest edit distance are dual problems. This is only true if the only possible you allow are insertions and deletions. Here we are also considering substitutions to be a single edit, which makes our upcoming description of the algorithm a bit different to his. For example, Myers would consider the edit distance of strings <code class="language-plaintext highlighter-rouge">ABA</code> and <code class="language-plaintext highlighter-rouge">AAA</code> to be 2 (delete <code class="language-plaintext highlighter-rouge">B</code> and insert <code class="language-plaintext highlighter-rouge">A</code>), whereas we consider it to be 1 (substitute <code class="language-plaintext highlighter-rouge">B</code> with <code class="language-plaintext highlighter-rouge">A</code>).</p><h1 id="the-myers-algorithm-for-edit-distance-calculation">The Myers algorithm for edit distance calculation</h1><p>If we are simply interested in the edit distance between $A$ and $B$, we only care about the value $D[m, n]$. In the recursion above, note that we always take the diagonal when $A[i] = B[j]$. In other words, the traceback of $D[m, n]$ is composed of vertical lines, horizontal lines, and a series of diagonals where there are huge runs of matches between substrings of $A$ and $B$. We can take advantage of these large diagonals if we rethink the edit distance problem appropriately.</p><p>From the Myers paper:</p><blockquote><p>“In practical situations, it is usually the parameter $d$ that is small. Programmers wish to know how they have altered a text file. Biologists wish to know how one DNA stand has mutated into another.”</p></blockquote><p>The idea of the Myers algorithm is to take advantage of these runs of diagonals by parametrizing the problem not by the prefix of the two strings, but by the diagonals of the edit distance matrix $D$. First, we denote $m + n - 1$ diagonals of the matrix by how far off they are from the main diagonal, so $k = 0$ is the main diagonal, $k = 1$ is one diagonal below the main, and $k = -1$ is one diagonal to the right of the main. In other words, the cells in diagonal $k$ are the cells $(x, y)$ where $x - y = k$.</p><p>We will show that, with this parametrization, we can find the edit distance of $A$ and $B$ in $\Theta((m + n) d)$, where $m$ is the length of $A$, $n$ is the length of $B$ and $d$ is the edit distance between $A$ and $B$. This is much faster than the traditional $\Theta (mn)$ when $A$ and $B$ are expected to be similar, and not asymptotically different when that is the case since $d \leq \mathrm{max}(m, n)$ when substitutions only count as one edit and $d \leq m + n$ when we only allow insertions and deletions (the Myers definition).</p><h3 id="the-furthest-reaching-point-of-diagonals"><span class="mr-2">The furthest-reaching point of diagonals</span><a href="#the-furthest-reaching-point-of-diagonals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>For diagonal $k$, let $V[d, k]$ be the <em>furthest reaching point</em> from the origin of diagonal $k$ when we are allowed $d$ non-diagonal changes (e.g. only insertions and deletions). In other words, $V$ is a pair of coordinates $(x, y)$ where $x$ (or $y$) is maximum and $(x, y)$ can be reached from $(k, 0)$ (if $k \geq 0)$ or $(0, -k)$ (if $k &lt; 0$) with $d$ edits. Then the edit distance of $A$ and $B$ is the minimum value of $d$ for which $V[d, k] = (m, n)$ for some $k$.</p><p>The key idea for the algorithm is that, for any diagonal the furthest reaching point with $d$ edits can be constructed easily from the furthest reaching points with $d - 1$ edits. First, if $d = 0$, $V[0, k]$ is found by the largest series of matches between either the suffix of $A$ starting at $k$ and $B$ or the suffix of $B$ starting at $k$ and $A$ (depending on the sign of $k$). For $d &gt; 0$, we can proceed as follows. Start with the furthest reaching points of $V[d-1, k-1]$, $V[d-1, k]$ and $V[d-1, k+1]$, both of which are one cell away from the diagonal $k$. Then we have a starting point at $k$ either by going one cell to the left, one cell down, or one diagonal cell from these two points, since these will increment one extra edit to get to diagonal $k$. Pick whichever of the two is furthest in diagonal $k$ to the origin, then go down diagonal $k$ on the series of matches between $A$ and $B$ until the first mismatch is found. When we find the point $(m, n)$ as the furthest reaching point for some pair $(d, k)$, the edit distance is $d$.</p><p>The algorithm takes $O((m+n)d)$ time and, if we are only interested in $d$, it takes $O(m+n)$ space. For $0 \leq d’ \leq d$ (i.e. all possible edit distances until our answer), we compute the furthest reaching point when we are allowed $d’$ edits. When $d’ = d$, we reach the endpoint $(m, n)$ and stop.</p><h1 id="an-short-implementation-of-the-algorithm">An short implementation of the algorithm</h1><p>Here is a C++ program that computes the edit distance between two strings passed on two lines of STDIN. The <code class="language-plaintext highlighter-rouge">edit_distance</code> function implemented below also takes a third parameter <code class="language-plaintext highlighter-rouge">MAX_D</code>, and stops trying to compute the edit distance if the answer goes above <code class="language-plaintext highlighter-rouge">MAX_D</code>. This has useful applications in the problems we stated above. For example, in read mapping, we will compare read to many sequences in the reference genome to which we are mapping the reads. In the seeding step, many of the retrieved sequences are false positives, and we want to stop comparing as soon as we realize that we will not get a satisfactory answer. This is normally done by setting a maximum acceptable number of edits, which we can use to accelerate our comparison.</p><p>A quick note about this code, which is easier to visualize with pen and paper: Suppose you are at diagonal <code class="language-plaintext highlighter-rouge">k</code> and your horizontal offset to the start of the diagonal is <code class="language-plaintext highlighter-rouge">x</code>. If you go one cell below to diagonal <code class="language-plaintext highlighter-rouge">k+1</code> your horizontal offset to this new diagonal is <code class="language-plaintext highlighter-rouge">x+1</code>. However, if you go one cell to the right to diagonal <code class="language-plaintext highlighter-rouge">k-1</code>, your offset at this new diagonal will still be <code class="language-plaintext highlighter-rouge">x</code>. Finally, if you go diagonally at diagonal <code class="language-plaintext highlighter-rouge">k</code>, you are still at diagonal <code class="language-plaintext highlighter-rouge">k</code>, but your horizontal offset is now <code class="language-plaintext highlighter-rouge">x+1</code>. This is the rational for lines 30 to 38 in the code below. The last thing to mention is that we do not need to keep a pair <code class="language-plaintext highlighter-rouge">(x, y)</code> as the furthest reaching point for diagonal <code class="language-plaintext highlighter-rouge">k</code>. If we know <code class="language-plaintext highlighter-rouge">x</code>, then <code class="language-plaintext highlighter-rouge">y = x - k</code>, so everything is parametrized by the horizontal offset <code class="language-plaintext highlighter-rouge">x</code>.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="c1">// we can use std::max from algorithm too, but this is faster</span>
<span class="kr">inline</span> <span class="kt">uint32_t</span>
<span class="nf">max32</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span><span class="o">:</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// edit distance function that stop if the distance is &gt; MAX_D</span>
<span class="kt">uint32_t</span>
<span class="nf">edit_distance</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">MAX_D</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">m</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">V</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">MAX_D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">Vp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">MAX_D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="kt">int32_t</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">D</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">D</span> <span class="o">&lt;=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MAX_D</span><span class="p">);</span> <span class="o">++</span><span class="n">D</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="n">D</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">D</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// from the diagonal: increment one position</span>
      <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">D</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">Vp</span><span class="p">[</span><span class="n">MAX_D</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

      <span class="c1">// from above: we are also one point farther from</span>
      <span class="c1">// the diagonal above us when we move one position down</span>
      <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="o">-</span><span class="n">D</span><span class="p">)</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">max32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Vp</span><span class="p">[</span><span class="n">MAX_D</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

      <span class="c1">// from the left: we are at the same diagonal position</span>
      <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">D</span><span class="p">)</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">max32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Vp</span><span class="p">[</span><span class="n">MAX_D</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>

      <span class="c1">// extend the reaching point with run of matches</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">k</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">y</span><span class="p">];</span> <span class="o">++</span><span class="n">x</span><span class="p">,</span> <span class="o">++</span><span class="n">y</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span> <span class="k">return</span> <span class="n">D</span><span class="p">;</span>
      <span class="n">V</span><span class="p">[</span><span class="n">MAX_D</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// copies the 2*D answers we found to use it in the next iteration</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">D</span> <span class="o">!=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MAX_D</span><span class="p">))</span>
      <span class="n">copy</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">+</span> <span class="n">MAX_D</span> <span class="o">-</span> <span class="n">D</span><span class="p">,</span> <span class="n">begin</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">+</span> <span class="n">MAX_D</span> <span class="o">+</span> <span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">begin</span><span class="p">(</span><span class="n">Vp</span><span class="p">)</span> <span class="o">+</span> <span class="n">MAX_D</span> <span class="o">-</span> <span class="n">D</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// edit distance &gt; MAX, reject comparison.</span>
  <span class="k">return</span> <span class="n">MAX_D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// general-purpose edit distance. If MAX_D not defined, then</span>
<span class="c1">// we use the maximum, which is |A| + |B|</span>
<span class="kt">uint32_t</span> <span class="nf">edit_distance</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">edit_distance</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">,</span>
                       <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">b</span><span class="o">:</span> <span class="n">a</span><span class="p">,</span>
                       <span class="n">max32</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"edit distance: "</span> <span class="o">&lt;&lt;</span> <span class="n">edit_distance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="benchmarking-the-algorithm">Benchmarking the algorithm</h1><p>I ran the edit distance calculation to find the difference between the human chromosome X in the human genome versions 37 (hg19) and 38 (hg38). For simplicity, I compared the first 1M characters of the two assemblies, then the first 10M characters. I also removed all Ns from both assemblies and converted letters to uppercase prior to comparison.</p><p>This is the result for the first 1M characters:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nv">$ </span>/usr/bin/time <span class="nt">-v</span> ./wavefront &lt;<span class="k">in</span><span class="nt">-1m</span>.txt
edit distance: 101430
  Command being timed: <span class="s2">"./wavefront"</span>
  Elapsed <span class="o">(</span>wall clock<span class="o">)</span> <span class="nb">time</span> <span class="o">(</span>h:mm:ss or m:ss<span class="o">)</span>: 0:55.59
  Maximum resident <span class="nb">set </span>size <span class="o">(</span>kbytes<span class="o">)</span>: 36512
  Exit status: 0
</pre></table></code></div></div><p>And this is the result for the first 10M characters:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nv">$ </span>/usr/bin/time <span class="nt">-v</span> ./wavefront &lt;<span class="k">in</span><span class="nt">-10m</span>.txt
edit distance: 285326
  Command being timed: <span class="s2">"./wavefront"</span>
  Elapsed <span class="o">(</span>wall clock<span class="o">)</span> <span class="nb">time</span> <span class="o">(</span>h:mm:ss or m:ss<span class="o">)</span>: 7:55.84
  Maximum resident <span class="nb">set </span>size <span class="o">(</span>kbytes<span class="o">)</span>: 335364
  Exit status: 0
</pre></table></code></div></div><p>The difference is a bit steep. We have 10% on the first 1M characters then less than 3% for 1M characters. Let us do 40M characters now!</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>edit distance: 330050
  Command being timed: <span class="s2">"./wavefront"</span>
  Elapsed <span class="o">(</span>wall clock<span class="o">)</span> <span class="nb">time</span> <span class="o">(</span>h:mm:ss or m:ss<span class="o">)</span>: 10:53.26
  Maximum resident <span class="nb">set </span>size <span class="o">(</span>kbytes<span class="o">)</span>: 1331500
  Exit status: 0
</pre></table></code></div></div><p>Looks like it’s less than 1% now! The more we compare, the more similar they become (though the number of edits is still increasing, which is encouraging to confirm that the algorithm is working).</p><p>Do note that 40M reads would require $\approx 10^{15}$ operations in the traditional edit distance algorithm proposed in the start of this post, so we made good progress for similar sequences apparently :)</p><p>In the next post we will extend this idea of “furthest reaching point” to affine local alignments to fully describe and implement the beautiful algorithm shown by Marco-Sola and colleagues!</p><h1 id="appendix-the-time-mappers-spend-aligning-reads">Appendix: The time mappers spend aligning reads</h1><p>To measure the alignment time, I took one million reads in a FASTQ file and ran both <a href="https://github.com/lh3/minimap2">minimap2</a> and <a href="https://github.com/smithlabcode/abismal">abismal</a> to map them to <code class="language-plaintext highlighter-rouge">hg38</code> (it doesn’t matter much how much error reads have, as long as it’s uniformly sampled from the genome). Using <code class="language-plaintext highlighter-rouge">perf record &lt;command&gt;</code>, we can store the time spent on each function in the program on a summary file, then the <code class="language-plaintext highlighter-rouge">perf report</code> reads the file and sorts the program functions by time spent, finally summarizes it to us on screen. It is an amazing profiling tool!</p><p>For <code class="language-plaintext highlighter-rouge">minimap2</code>, here is the result:</p><p><img data-src="https://i.ibb.co/JzrWGkp/minimap2.jpg" alt="results of perf for minimap2" data-proofer-ignore></p><p>For <code class="language-plaintext highlighter-rouge">abismal</code>, here is the result:</p><p><img data-src="https://i.ibb.co/kqdXvZz/abismal.jpg" alt="results of perf for abismal" data-proofer-ignore></p><ul><li>In <code class="language-plaintext highlighter-rouge">minimap2</code>, we can see that 36.86% of the time is spent at function <code class="language-plaintext highlighter-rouge">ksw_extd2_sse41</code>. This is the beautiful SSE implementation of Smith-Waterman in the mapper, which we will cover in more detail in another post.<li>In <code class="language-plaintext highlighter-rouge">abismal</code> we have 33.67% of the time on <code class="language-plaintext highlighter-rouge">process_seeds</code> and 16.32% of the time on <code class="language-plaintext highlighter-rouge">AbismalAlign</code>. The <code class="language-plaintext highlighter-rouge">process_seeds</code> step compares reads to hits using only Hamming distance, and the <code class="language-plaintext highlighter-rouge">AbismalAlign::align&lt;false&gt;</code> function is the banded Smith-Waterman algorithm (the “false” in the template means to only calculate score, not traceback/CIGAR string).</ul><p>In both cases, we can see that the bulk of time is not in collecting seeds, finding them in the genome, ecoding or any other secondary operation. Instead, the alignment itself comprises the majority of the mapping effort, which greatly motivates fast implementations of the algorithms we have available today.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/c/'>C++</a>, <a href='/categories/alignment-algorithms/'>alignment-algorithms</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://t.me/share/url?url=%2Fposts%2Fwavefront-pt-1%2F&text=Wavefront+alignments+pt+1+%3A+The+Myers+edit+distance+algorithm+-+Guilherme+Sena" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/possibly-the-most-naive-phylogenetic-reconstruction-algorithm/">The most naive phylogenetic reconstruction algorithm</a><li><a href="/posts/setting-up-a-blog/">Setting up a blog</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/possibly-the-most-naive-phylogenetic-reconstruction-algorithm/"><div class="card-body"> <em class="small" data-ts="1658102400" data-df="ll" > Jul 18, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The most naive phylogenetic reconstruction algorithm</h3><div class="text-muted small"><p> The full source code for this post can be found on GitHub. This post was motivated by the following question: what would be the simplest problem we could formulate to introduce a computer science ...</p></div></div></a></div><div class="card"> <a href="/posts/setting-up-a-blog/"><div class="card-body"> <em class="small" data-ts="1576022400" data-df="ll" > Dec 11, 2019 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Setting up a blog</h3><div class="text-muted small"><p> I am configuring this blog if I want to communicate, write or document things using markdown and figures. This post is to test if I can write some code with syntax highlight and some math. Here’s ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/possibly-the-most-naive-phylogenetic-reconstruction-algorithm/" class="btn btn-outline-primary" prompt="Older"><p>The most naive phylogenetic reconstruction algorithm</p></a><div class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></div></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/senacompbio">Guilherme Sena</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
